external {
    fn puts(str: *const u8) -> i32
    
    fn abort() __noreturn -> void
}

type Hello = &mut [isize]

const pi: f64 = 3.14159265

struct Point {
    x: f64 
    y: f64
}

fn test() -> i32 {
    5
}

fn main() -> void {
    let binding: fn(i32, f64) -> void = nil

    pi

    let pi = 3

    pi

    if true then 1 else 0

    let pt = Point { x: 64.3, y: 0.0 }

    let y = pt.x

    let foo: [i64; 4] = [1, 2, 3, 4]

    while true {
        let y = 5

        y
    }

    pi == pi

    5 == 5



    // ::puts(1, 2, 3)
    // puts("Hello")
    // puts()
    // puts(nil)

    // binding(1, 0)

    test(2525)

    // ::puts(5 as *const u8)

    1 + 2 / 3 * 4 % 5


    if true {
        if false then 1 else 2 
    } elif false {
        pt.x as i64
    } else {
        test() as i64
    }
}


fn g() -> *mut i64 { 
    nil
}


fn f(x: i64) -> void {}

export extern fn lol() -> *mut byte {
    mut point = Point { x: 5.0, y: 0.0 }
    mut arr = [1, 2, 3, 4, 5]
    let ref = &mut point 

    point.x := 6.0
    arr[0] := 7
    *ref := Point { x: 0.0, y: 0.0 }

    Point

    nil
}
